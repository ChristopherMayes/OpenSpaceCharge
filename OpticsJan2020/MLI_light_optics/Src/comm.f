************************************************************************
* header:                 COMMANDS (simple)
*  These modules deal with simple commands that affect maps and phase
*  space data.  Ray trace related commands are found in TRAC, and input
*  output related commands are found in INPU.
*
* Rob Ryne 7/28/2002
* This file was generated by taking comm.f from the 5th order version
* that Tom Mottershead and I were using and including the following
* from the ML30dev version:
* cmom, cmom5, dpol, tpol
* also, wnda and wnd were added to replace swnd and dwnd 
* Note that, in cmom5 (which is not used), monoms5 has been replaced by monom
* Note also that evalm and evalm5 (not used) have been added to liea.f
************************************************************************
c
      subroutine cmom(amom,am)
c this subroutine computes the moments of the particle distribution
c stored in zblock.  The second moments are put in the matrix am, and
c all the moments are put in the array amom.
c Written by Alex Dragt, 1 July 1991.
c
      use rays
      use lieaparam, only : monoms
      include 'impli.inc'
c
c calling arrays
      dimension am(6,6)
      dimension amom(monoms)
c
c working arrays
      dimension vmon(monoms)
      dimension z(6)
c
c clear amom
      do 5 i=1,monoms
    5 amom(i)=0.d0
c
c computational loop
      do 10 k=1,nraysp
c get a ray
      do 20 i=1,6
   20 z(i)=zblock(i,k)
c compute moments for the ray
      call evalm(z,vmon)
c add results to moment sum
      do 30 i=1,monoms
   30 amom(i)=amom(i)+vmon(i)
   10 continue
c
c normalize by the number of particles
      fact=1.d0/float(nrays)
      do 40 i=1,monoms
   40 amom(i)=fact*amom(i)
c
c also put second moments in the matrix part am
c
      am(1,1)=amom(7)
      am(1,2)=amom(8)
      am(1,3)=amom(9)
      am(1,4)=amom(10)
      am(1,5)=amom(11)
      am(1,6)=amom(12)
      am(2,1)=amom(8)
      am(2,2)=amom(13)
      am(2,3)=amom(14)
      am(2,4)=amom(15)
      am(2,5)=amom(16)
      am(2,6)=amom(17)
      am(3,1)=amom(9)
      am(3,2)=amom(14)
      am(3,3)=amom(18)
      am(3,4)=amom(19)
      am(3,5)=amom(20)
      am(3,6)=amom(21)
      am(4,1)=amom(10)
      am(4,2)=amom(15)
      am(4,3)=amom(19)
      am(4,4)=amom(22)
      am(4,5)=amom(23)
      am(4,6)=amom(24)
      am(5,1)=amom(11)
      am(5,2)=amom(16)
      am(5,3)=amom(20)
      am(5,4)=amom(23)
      am(5,5)=amom(25)
      am(5,6)=amom(26)
      am(6,1)=amom(12)
      am(6,2)=amom(17)
      am(6,3)=amom(21)
      am(6,4)=amom(24)
      am(6,5)=amom(26)
      am(6,6)=amom(27)
c
c     write(6,*)'here I am in cmom; amom(1-27)='
c     do i=1,27
c     write(6,*)i,amom(i)
c     enddo
c 
      return
      end
c
******************************************************************
c
      subroutine dpol(p,fa,fm)
c This is a subroutine for setting up a quadratic polynomial
c described in terms of dispersion parameters.
c Written by Alex Dragt, 29 March 1991
c
      use lieaparam, only : monoms
      include 'impli.inc'
c
      dimension fa(monoms)
      dimension fm(6,6)
      dimension p(6)
c
c set map to the identity
      call ident(fa,fm)
c
c set up polynomial
      fa(12)=p(2)
      fa(17)=-p(1)
      fa(21)=p(4)
      fa(24)=-p(3)
      fa(27)=-p(5)/2.d0
c
      return
      end
c
*********************************************************************
c
      subroutine eapt(p)
c  this is a subroutine for an elliptic aperture
c  Written by Alex Dragt, Spring 1987.
      use rays
      include 'impli.inc'
      dimension p(6)
c
      smas=p(2)
      raxs=p(3)
      iturn=iturn+1
      do 100 k=1,nraysp
      if (istat(k).ne.0) goto 100
      x=zblock(1,k)
      y=zblock(3,k)
      x2=x*x
      y2=y*y
      test=x2+raxs*y2
c  examine particle location
      if (test.ge.smas) goto 10
c  particle within aperture
      goto 100
  10  continue
c  particle outside aperture
      istat(k)=iturn
      nlost=nlost+1
      ihist(1,nlost)=iturn
      ihist(2,nlost)=k
 100  continue
      return
      end
c
*********************************************************************
c
      subroutine ftm(p,fa,fm)
c  this subroutine filters transfer maps
c  Written by Alex Dragt, Spring 1987.
      use lieaparam, only : monoms
      include 'impli.inc'
      include 'files.inc'
      dimension p(6),fa(monoms),fm(6,6)
      dimension ta(monoms),tm(6,6)
c
      ifile=nint(p(1))
      nopt=nint(p(2))
      nskp=nint(p(3))
      kynd=nint(p(4))
      mpitmp=mpi
      mpi=ifile
      call mapin(nopt,nskp,ta,tm)
      mpi=mpitmp
c  determine procedure
      if(kynd.eq.0) goto 5
      if(kynd.eq.1) goto 15
c  procedure for normal filter
   5  continue
      do 10 i=1,monoms
      if(ta(i).eq.0.) fa(i)=0.
  10  continue
      return
c  procedure for a reversed filter
  15  continue
      do 20 i=1,monoms
      if(ta(i).gt.0.) fa(i)=0.
  20  continue
      return
      end
c
***********************************************************************
c
      subroutine ident(h,xmh)
c Written by D. Douglas, ca 1982
      use lieaparam, only : monoms
      include 'impli.inc'
      dimension h(monoms),xmh(6,6)
      do 10 i=1,6
      do 10 j=1,6
   10 xmh(i,j)=0.
      do 15 i=1,6
   15 xmh(i,i)=1.
      do 20 i=1,monoms
   20 h(i)=0.
c
      return
      end
c
***********************************************************************
c
      subroutine inv(ha,hm)
c  Returns the inverse of the map represented by ha,hm
c  based on the reverse to Marylie order factorization
c  routine cfacrm.  Written 2/2/96 AJD
c
      include 'impli.inc'
c
c----Variables----
c
      dimension ha(*),hm(6,6)
c
c----Routine----
c
c  Invert matrix part of map.
      call minv(hm)
c  Reverse sign of polynomials:
      do 100 ind=1,923
  100   ha(ind)=-ha(ind)
c Now reverse order:
      call cfacrm(ha,hm)
c
      return
      end
c
*********************************************************************
c
      subroutine mask6(wipe,h,mh)
c
c  Sets higher order monomial coefficients to zero as specified by wipe
c  Written by Liam Healy, Spring 1985
c
c     implicit none
c  Variables
c  wipe = array of flags: if nth element is less than 0.5, nth order is
c         set to the identity map
      double precision wipe(*)
c  h, mh = polynomial and matrix (input and output)
      double precision h(*),mh(6,6)
c  ord = order of polynomial
      integer ord
c
      include 'maxcat.inc'
      include 'lims.inc'
c
c----Routine----
      if (wipe(1).le.0.5) then
        do 100 i=1,6
          do 100 j=1,6
  100       mh(i,j)=0.
        do 120 i=1,6
  120     mh(i,i)=1.
      endif
      do 200 ord=2,ordcat
        if (wipe(ord).le.0.5) then
          do 140 i=bottom(ord),top(ord)
  140       h(i)=0.
        endif
  200 continue
      return
      end
c
*********************************************************************
c
      subroutine mask(akeep,ha,hm)
c
c  Keeps or removes portions of the map as specified by akeep.
c  Written by A. Dragt 2/3/96 to work thru f6.
c
      include 'impli.inc'
      include 'maxcat.inc'
      include 'lims.inc'
c
cryne 12/31/2004:
      integer keep
c
c  Variables
c
c  akeep = array of flags: 
      dimension akeep(*)
c  ha, hm = polynomial and matrix (input and output)
      dimension ha(*),hm(6,6)
c  keep = integer version of akeep
      dimension keep(6)
c
c----Routine----
c
c set up keep
      do 10 i=1,6
   10 keep(i) = nint(akeep(i))
c
c mask the map order by order
c
c f1 contents:
      if (keep(1) .eq. 0) then
      do 100 i=1,6
  100 ha(i) = 0.d0
      endif
c f2 and matrix contents:
      if (keep(2) .eq. 0) then
      do 200 i=7,27
  200 ha(i) = 0.d0
      call mident(hm)
      endif
c f3 contents:
      if (keep(3) .eq. 0) then
      do 300 i=28,83
  300 ha(i) = 0.d0
      endif
c f4 contents:
      if (keep(4) .eq. 0) then
      do 400 i=84,209
  400 ha(i) = 0.d0
      endif
c f5 contents:
      if (keep(5) .eq. 0) then
      do 500 i=210,461
  500 ha(i) = 0.d0
      endif
c f6 contents:
      if (keep(6) .eq. 0) then
      do 600 i=462,923
  600 ha(i) = 0.d0
      endif
c
      return
      end
c
***********************************************************************
c
      subroutine mtran(mh)
c  Takes the transpose of the matrix mh.
c  Written by Liam Healy, April 16, 1985.
c     implicit none
      double precision mh(6,6),hold
      integer i,j
c
c----Routine----
      do 100 i=1,6
        do 100 j=1,i-1
          hold=mh(j,i)
          mh(j,i)=mh(i,j)
          mh(i,j)=hold
  100 continue
      return
      end
c
***********************************************************************
c
      subroutine rapt(p)
c  this is a subroutine for a rectangular aperture
c  Written by Alex Dragt, Spring 1987.
      use beamdata
      use rays
      include 'impli.inc'
      dimension p(*)
c
c     if(idproc.eq.0)then
c       write(6,*)'inside rectangular aperture routine'
c     endif
      xmin=p(1)
      xmax=p(2)
      ymin=p(3)
      ymax=p(4)
      iturn=iturn+1
      do 100 k=1,nraysp
      if (istat(k).ne.0) goto 100
      x=sl*zblock(1,k)
      y=sl*zblock(3,k)
c  examine particle location
      if (x.le.xmin) goto 10
      if (x.ge.xmax) goto 10
      if (y.le.ymin) goto 10
      if (y.ge.ymax) goto 10
c  particle within aperture
      goto 100
  10  continue
c  particle outside aperture
      write(6,*)'particle #',k,' from proc ',idproc,' is lost'
      istat(k)=iturn
      nlost=nlost+1
      ihist(1,nlost)=iturn
      ihist(2,nlost)=k
 100  continue
      return
      end
c
***********************************************************************
c
      subroutine rev(h,mh)
c This is a subroutine for reversing a map.
c Written by Alex Dragt on Friday, 13 Sept 1985.
      use lieaparam, only : monoms
c     implicit none
      include 'expon.inc'
c
      double precision h(*),mh(6,6)
      double precision temp(6,6)
      double precision r(6,6)
c Define the reversing matrix r by a set of data statements:
      data (r(1,j),j=1,6)/ 1.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0/
      data (r(2,j),j=1,6)/ 0.d0,-1.d0, 0.d0, 0.d0, 0.d0, 0.d0/
      data (r(3,j),j=1,6)/ 0.d0, 0.d0, 1.d0, 0.d0, 0.d0, 0.d0/
      data (r(4,j),j=1,6)/ 0.d0, 0.d0, 0.d0,-1.d0, 0.d0, 0.d0/
      data (r(5,j),j=1,6)/ 0.d0, 0.d0, 0.d0, 0.d0,-1.d0, 0.d0/
      data (r(6,j),j=1,6)/ 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.d0/
      save r
c----Routine----
c Compute inverse map:
      call inv(h,mh)
c Reverse matrix portion of map:
      call mmult (r,mh,temp)
      call mmult (temp,r,mh)
c Reverse polynomial portion of map:
c For now, work only with n in the interval [28,209].
c Change range of n later when f1's are implemented.
      do 10 n=28,209
        n2 = expon(2,n)
        n4 = expon(4,n)
        n5 = expon(5,n)
        m = n2+n4+n5
        mm2 = mod(m,2)
        if (mm2.eq.0) h(n)=-h(n)
   10 continue
      return
      end
c
***********************************************************************
c
      subroutine revf(iord,ha,hm)
c  Changes the order of factorization.
c  If iord=0, it is assumed that the map specified by ha,hm is in the
c  standard MARYLIE order exp(:f2:)exp(:f3:)exp(:f4)....  This
c  routine will then return g3,g4... corresponding to the factorization
c  ...exp(:g4:)exp(:g3:)exp(:f2:).
c  If iord=1, it is assumed that the map specified by ha,hm is in
c  reversed order.  This routine then returns the standard
c  MARYLIE order.  Written by Alex Dragt 1/31/96
c
      include 'impli.inc'
c
c----Variables----
c
      dimension ha(*),hm(6,6)
c
c----Routine----
c
      if(iord.gt.0) then
c
c----Procedure for going from reversed order to MARYLIE order:
c
      call cfacrm(ha,hm)
c
      else
c
c----Procedure for going from MARYLIE order to reversed order:
c
      call cfacmr(ha,hm)
c
      endif
c
      return
      end
c
***********************************************************************
c
      subroutine cfacmr(ha,hm)
c  Changes the order of factorization from Marylie to reversed order
c  using the inversion routine.
c  Written by Alex Dragt 1/31/96
c
c----Variables----
c
      include 'impli.inc'
c
      dimension ha(*),hm(6,6)
      dimension ha1(923),hm1(6,6)
      dimension ha2(923),hm2(6,6)
c
c----Routine----
c
c----Procedure for going from MARYLIE order to reversed order:
c
c  Clear ha1,hm1
      call clear(ha1,hm1)
c  Copy hm into hm1
      call matmat(hm,hm1)
c  Invert the map ha,hm
      call inv(ha,hm)
c  Concatenate with the map ha1,hm1
      call concat(ha1,hm1,ha,hm,ha2,hm2)
c  Change signs of monomials
      do 120 ind=1,923
  120   ha(ind)=-ha2(ind)
c  Replace current hm with its original version, hm1
      call matmat(hm1,hm)
c
      return
      end
c
***********************************************************************
c
      subroutine cfacrm(ha,hm)
c  Changes the order of factorization from reversed to
c  Marylie order using the concatenator.
c  Written by Alex Dragt 1/31/96
c
c----Variables----
c
      include 'impli.inc'
c
      dimension ha(923),hm(6,6)
      dimension ha1(923),hm1(6,6)
      dimension ha2(923),hm2(6,6)
      dimension ha3(923),hm3(6,6)
      dimension akeep(6)
c
c----Routine----
c
c----Procedure for going from reversed order to MARYLIE order:
c--- This should work thru 6th order (AJD)
c
c get only matrix part
      call mapmap(ha,hm,ha1,hm1)
      akeep(1)=0.
      akeep(2)=1.d0
      akeep(3)=0.
      akeep(4)=0.
      akeep(5)=0.
      akeep(6)=0.
      call mask(akeep,ha1,hm1)
c get only g3 part
      call mapmap(ha,hm,ha2,hm2)
      akeep(1)=0.
      akeep(2)=0.
      akeep(3)=1.d0
      akeep(4)=0.
      akeep(5)=0.
      akeep(6)=0.
      call mask(akeep,ha2,hm2)
c concatenate exp(:g3:)exp(:g2:)
      call concat(ha2,hm2,ha1,hm1,ha3,hm3)
c store result in ha1,hm1
      call mapmap(ha3,hm3,ha1,hm1)
c get only g4 part
      call mapmap(ha,hm,ha2,hm2)
      akeep(1)=0.
      akeep(2)=0.
      akeep(3)=0.
      akeep(4)=1.d0
      akeep(5)=0.
      akeep(6)=0.
      call mask(akeep,ha2,hm2)
c concatenate exp(:g4:)exp(:g3:)exp(:g2:)
      call concat(ha2,hm2,ha1,hm1,ha3,hm3)
c store result in ha1,hm1
      call mapmap(ha3,hm3,ha1,hm1)
c      write(6,*) 'result after g4'
c      call pcmap(1,1,0,0,ha1,hm1)
c get only g5 part
      call mapmap(ha,hm,ha2,hm2)
      akeep(1)=0.
      akeep(2)=0.
      akeep(3)=0.
      akeep(4)=0.
      akeep(5)=1.d0
      akeep(6)=0.
      call mask(akeep,ha2,hm2)
c      write(6,*) 'first factor'
c      call pcmap(1,1,0,0,ha2,hm2)
c      write(6,*) 'second factor'
c      call pcmap(1,1,0,0,ha1,hm1)
c concatenate exp(:g5:)exp(:g4:)exp(:g3:)exp(:g2:)
      call concat(ha2,hm2,ha1,hm1,ha3,hm3)
c      write(6,*) 'result after concat'
c      call pcmap(1,1,0,0,ha3,hm3)
c store result in ha1,hm1
      call mapmap(ha3,hm3,ha1,hm1)
c      write(6,*) 'result after g5 mapmap'
c      call pcmap(1,1,0,0,ha1,hm1)
c get only g6 part
      call mapmap(ha,hm,ha2,hm2)
      akeep(1)=0.
      akeep(2)=0.
      akeep(3)=0.
      akeep(4)=0.
      akeep(5)=0.
      akeep(6)=1.d0
      call mask(akeep,ha2,hm2)
c      write(6,*) 'result after g6 mask'
c      call pcmap(1,1,0,0,ha2,hm2)
c concatenate exp(:g6:)exp(:g5:)exp(:g4:)exp(:g3:)exp(:g2:) 
c and put result in ha,hm.
      call concat(ha2,hm2,ha1,hm1,ha,hm)
c
      end
c
***********************************************************************
c
      subroutine strget(kynd,nmap,fa,fm)
cryne 12/15/2004 modified to use new common block structure of stmap.inc
c
c This is a subroutine for storing and getting maps.
c A total of 5 maps can be stored and retrieved.
c The incoming and outgoing maps are represented by fa,fm.
c In the store mode, the maps are stored in sf1,sm1 to sf5,sm5.
c In the retrieve mode, the map is gotten from sf1,sm1 to sf5,sm5.
c The maps sf1,sm1 to sf5,sm5 are stored in the block common stmap.
c Written by Alex Dragt, Spring 1987. Modified 10/13/88 AJD.
c
      use lieaparam, only : monoms
      use parallel
      include 'impli.inc'
      include 'files.inc'
      include 'stmap.inc'
      character*3 kynd
c
c Calling arrays
      dimension fa(monoms),fm(6,6)
c
c
cryne fix later so that "20" is not hardwired
      if(nmap.gt.20)then
        if(idproc.eq.0)write(6,*)'ERROR: too many stored maps'
        if(idproc.eq.0)write(6,*)'nmap=',nmap
        call myexit
      endif
c
      if (kynd.eq.'gtm') goto 100
c Procedure for storing maps:
      write(jof,400) nmap
  400 format(1x,'map stored in location',2x,i2)
!     goto(10,20,30,40,50),nmap
!  10 call mapmap(fa,fm,sf1,sm1)
!     return
!  20 call mapmap(fa,fm,sf2,sm2)
!     return
!  30 call mapmap(fa,fm,sf3,sm3)
!     return
!  40 call mapmap(fa,fm,sf4,sm4)
!     return
!  50 call mapmap(fa,fm,sf5,sm5)
      call mapmap(fa,fm,storedpoly(1,nmap),storedmat(1,1,nmap))
      return
c
c Procedure for getting maps:
  100 continue
!!!!!      write(jof,450) nmap
!!!!!  450 format(1x,'map gotten from location',2x,i2)
!     goto(110,120,130,140,150),nmap
! 110 call mapmap(sf1,sm1,fa,fm)
!     return
! 120 call mapmap(sf2,sm2,fa,fm)
!     return
! 130 call mapmap(sf3,sm3,fa,fm)
!     return
! 140 call mapmap(sf4,sm4,fa,fm)
!     return
! 150 call mapmap(sf5,sm5,fa,fm)
      call mapmap(storedpoly(1,nmap),storedmat(1,1,nmap),fa,fm)
c
      return
      end
c
*********************************************************************
c
      subroutine sympl(itype,fa,fm)
c  This is a symplectification subroutine
c Written by Alex Dragt, Spring 1987.
      use lieaparam, only : monoms
      include 'impli.inc'
      dimension fa(monoms),fm(6,6)
c
      if (itype.eq.1) call sympl1(fm)
      if (itype.eq.2) call sympl2(fm)
      if (itype.eq.3) call sympl3(fm)
c
      return
      end
c
*********************************************************************
c
      subroutine tpol(p,fa,fm)
c This is a subroutine for computing a quadratic polynomial
c described in terms of twiss parameters.
c Written by Alex Dragt, 21 December 1990
      include 'impli.inc'
      include 'param.inc'
      dimension p(6)
      dimension fa(monoms),fm(6,6)
c-----
c set map to the identity
      call ident(fa,fm)
c set up twiss parameters
      ax=p(1)
      bx=p(2)
      ay=p(3)
      by=p(4)
      at=p(5)
      bt=p(6)
      if(bx .gt. 0.d0) gx=(1.+ax*ax)/bx
      if(by .gt. 0.d0) gy=(1.+ay*ay)/by
      if(bt .gt. 0.d0) gt=(1.+at*at)/bt
      if (bx .le. 0.) then
      ax=0.
      bx=0.
      gx=0.
      endif
      if (by .le. 0.) then
      ay=0.
      by=0.
      gy=0.
      endif
      if (bt .le. 0.) then
      at=0.
      bt=0.
      gt=0.
      endif
c set up polynomial
      fa(7)=gx
      fa(8)=2.d0*ax
      fa(13)=bx
      fa(18)=gy
      fa(19)=2.d0*ay
      fa(22)=by
      fa(25)=gt
      fa(26)=2.d0*at
      fa(27)=bt
      return
      end
c
c**********************************************************************
c
      subroutine wnd(pp)
c  this is a subroutine for windowing tracking results in
c  all six variables.
c  Written by Alex Dragt, 12 January 1991.
      use rays
      include 'impli.inc'
      dimension pp(6)
c
c set up control parameters
      iplane=nint(pp(1))
      if ((iplane .lt. 1) .or. (iplane .gt. 3)) then
      write(6,*) 'iplane out of range in wnd'
      return
      endif
      icon=2*(iplane - 1)
      qmin=pp(2)
      qmax=pp(3)
      pmin=pp(4)
      pmax=pp(5)
c
      iturn=iturn+1
      do 100 k=1,nrays
      if (istat(k).ne.0) goto 100
c  examine particle
      q=zblock(1+icon,k)
      p=zblock(2+icon,k)
      if   (q.lt.qmin .or. q.gt.qmax
     & .or. p.lt.pmin .or. p.gt.pmax)
     & then
c  particle outside window
      istat(k)=iturn
      nlost=nlost+1
      ihist(1,nlost)=iturn
      ihist(2,nlost)=k
      endif
 100  continue
      return
      end
c
***********************************************************************
c
      subroutine wnda(p)
c  this is a subroutine for windowing tracking results in all planes
c  simultaneously.
c  Written by Alex Dragt, Spring 1987.
      use rays
      include 'impli.inc'
      dimension p(6)
c
      iturn=iturn+1
      do 100 k=1,nraysp
      if (istat(k).ne.0) goto 100
c  examine particle location
      ax=abs(zblock(1,k))
      apx=abs(zblock(2,k))
      ay=abs(zblock(3,k))
      apy=abs(zblock(4,k))
      at=abs(zblock(5,k))
      apt=abs(zblock(6,k))
      if (ax.gt.p(1) .or. apx.gt.p(2)
     & .or. ay.gt.p(3) .or. apy.gt.p(4)
     & .or. at.gt.p(5) .or. apt.gt.p(6))
     & then
c  particle outside window
      istat(k)=iturn
      nlost=nlost+1
      ihist(1,nlost)=iturn
      ihist(2,nlost)=k
      endif
 100  continue
      return
      end
c
c end of file
c
c *************the remaining routines are no longer needed**************
c
      subroutine cmom5(amom)
c this subroutine computes the moments of the particle distribution
c stored in zblock.  The moments are put in the array amom.
c Written by Alex Dragt, 1 July 1991.
c Modified to generate <5> and <6>, by Johannes van Zeijts, 11 November 1991.
c
      use rays
      use lieaparam, only : monoms
      include 'impli.inc'
c
c calling arrays
      dimension amom(monoms)
c
c working arrays
      dimension vmon(monoms)
      dimension z(6)
c
c clear amom
      do 5 i=1,monoms
    5 amom(i)=0.d0
c
c computational loop
      do 10 k=1,nraysp
c get a ray
      do 20 i=1,6
   20 z(i)=zblock(i,k)
c compute moments for the ray
cryne      call evalm5(z,vmon)
      call evalm(z,vmon)
c add results to moment sum
      do 30 i=1,monoms
   30 amom(i)=amom(i)+vmon(i)
   10 continue
c
c normalize by the number of particles
      fact=1.d0/float(nrays)
      do 40 i=1,monoms
   40 amom(i)=fact*amom(i)
c
      return
      end
c
*********************************************************************
c
      subroutine dwnd(p)
c  this is a subroutine for windowing tracking results from a dynamic ma
c  Written by Alex Dragt, Spring 1987.
      use rays
      include 'impli.inc'
      dimension p(6)
c
      iturn=iturn+1
      do 100 k=1,nraysp
      if (istat(k).ne.0) goto 100
c  examine particle location
      ax=abs(zblock(1,k))
      apx=abs(zblock(2,k))
      ay=abs(zblock(3,k))
      apy=abs(zblock(4,k))
      at=abs(zblock(5,k))
      apt=abs(zblock(6,k))
      if (ax.gt.p(1) .or. apx.gt.p(2)
     & .or. ay.gt.p(3) .or. apy.gt.p(4)
     & .or. at.gt.p(5) .or. apt.gt.p(6))
     & then
c  particle outside window
      istat(k)=iturn
      nlost=nlost+1
      ihist(1,nlost)=iturn
      ihist(2,nlost)=k
      endif
 100  continue
      return
      end
c
*********************************************************************
c
      subroutine swnd(p)
c  this is a subroutine for windowing tracking results from a static map
c  Written by Alex Dragt, Spring 1987.
      use rays
      include 'impli.inc'
      dimension p(6)
c
      iturn=iturn+1
      do 100 k=1,nraysp
      if (istat(k).ne.0) goto 100
c  examine particle location
      ax=abs(zblock(1,k))
      apx=abs(zblock(2,k))
      ay=abs(zblock(3,k))
      apy=abs(zblock(4,k))
      if (ax.gt.p(1) .or. apx.gt.p(2)
     & .or. ay.gt.p(3) .or. apy.gt.p(4))
     & then
c  particle outside window
      istat(k)=iturn
      nlost=nlost+1
      ihist(1,nlost)=iturn
      ihist(2,nlost)=k
      endif
 100  continue
      return
      end
c end of file
